


\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{amsthm}
\usepackage{amsthm,amsmath,amsfonts,amssymb,amstext}
\usepackage{latexsym,ifthen,url,rotating}
\usepackage[usenames,dvipsnames]{color}


% --- -----------------------------------------------------------------
% --- Document-specific definitions.
% --- -----------------------------------------------------------------
\newtheorem{definition}{Definition}

\newcommand{\concat}{{\,\|\,}}
\newcommand{\bits}{\{0,1\}}
\newcommand{\Range}{{\mathrm{Range}}}
\newcommand{\A}{{\mathcal{A}}}

% --- -----------------------------------------------------------------
% --- The document starts here.
% --- -----------------------------------------------------------------
\begin{document}
%\maketitle

\noindent CS513: Design and Analysis of Data Structures and Algorithms \\
        Group: Stewart Smith and Kaushal Parikh\\

        \begin{center}
        \LARGE{\textbf{Homework 2}}\\
            \end{center}

            \vspace{.1in}


            \begin{enumerate}

            \item \\
                T(n) = 2T(n/2)+\log n \\
                f(n) = \log n \\
                a = 2, b = 2 \\
                a > \log _2 2 \\
                $ via Master Theorem \\$
                T(n) = \Theta(n ^ {(\log _b a)}) = \Theta(n)\\
            \item \\
            \item \\
            \item \\
            \item \\
            \item Algorithm:
                    \begin{verbatim}
                    HamC(G):
                        for each pair of neighbors(n1, n2):
                            if HamP(n1, n2, G):
                                return true
                        return false
                    \end{verbatim}

                    This approach will tell us if our graph has an hamiltonian circuit. \\
                    We are going through each pair of neighbors, which for a fully connect graph is going to be $n^2$ complexity\\
                    That makes our big O run time for the algorithm $n^2 * n^c = O(n^c)$, polynomial time\\
                    \\
            \item
               Algorithm:
               \begin{verbatim}
                findPath(n1, n2):
                    newPath
                    for each neighbor of n1 s:
                        if HamP(s, n1):
                            append s to newPath
                            findPath(s, n1)
               \end{verbatim}\\

               This approach will find us a hamiltonian path.\\
               The solution is to go to each neighbor and run the findPath algorithm on it again. \\
               This makes a new graph that consists only of the hamiltonian path.\\

            \end{enumerate}

                                \end{document}

