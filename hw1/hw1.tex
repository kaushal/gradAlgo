


\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{amsthm}
\usepackage{amsthm,amsmath,amsfonts,amssymb,amstext}
\usepackage{latexsym,ifthen,url,rotating}
\usepackage[usenames,dvipsnames]{color}


% --- -----------------------------------------------------------------
% --- Document-specific definitions.
% --- -----------------------------------------------------------------
\newtheorem{definition}{Definition}

\newcommand{\concat}{{\,\|\,}}
\newcommand{\bits}{\{0,1\}}
\newcommand{\Range}{{\mathrm{Range}}}
\newcommand{\A}{{\mathcal{A}}}

% --- -----------------------------------------------------------------
% --- The document starts here.
% --- -----------------------------------------------------------------
\begin{document}
%\maketitle
\sloppy

\noindent CS513: Design and Analysis of Data Structures and Algorithms \\
Group: Stewart Smith and Kaushal Parikh\\

\begin{center}
    \LARGE{\textbf{Homework 1}}\\
\end{center}

\vspace{.1in}

\begin{enumerate}

\item Prove: A binary tree with n nodes has depth at least blog nc and at most n􀀀1. (Hint:: Show that if a binary tree has depth d and has n nodes, then n  2d+1 􀀀 \\
    $$n\leq 2^{d+1}-1\\
    $$n+1\leq 2^{d+1}\\
    log_2 \leq d+1\\

\item Prove log(n!) \in \Theta({nlogn})\\
    log(n!) = log(1) + log(2) + \cdots + log(n) \leq{log(n) + log(n) + \cdots  + log(n)}\\
    log(n!) \in O(nlogn)\\

\item (a) Assume: \sum_{i=1}^k i(i+1) = \frac1 3 k(k+1)(k+2)\\
    Prove:  \sum_{i=1}^{(k+1)} i(i+1) = \frac1 3 (k+1)(k+2)(k+3)\\
    \sum_{i=1}^{(k+1)} i(i+1) = \sum_{i=1}^k i(i+1) + (k+1)(k+2)\\
    = \frac1 3 k(k+1)(k+2) + (k+1)(k+2)\\
    = (k+1)(k+2) (\frac k3 + 1)\\
    = \frac1 3 (k+1)(k+2)(k+3)\\
    (b)\\
    Assume: \sum_{i=0}^k i2^i = (k-1)2^{k+1}+2\\
    Prove:  \sum_{i=0}^{k+1} i2^i = k2^{k+2}+2\\
    = \sum_{i=0}^k i2^i + (k+1)2^{k+1}\\
    = (k-1)2^{k+1}+2 + (k+1)2^{k+1}\\
    = 2^{k+1}(2k)\\
    = k2^{k+2} + 2\\
    (c)\\
    Assume: $\sum_{i=0}^k \frac i2^{i} = (k-1)2^{k+1}+2$\\

\item
    consult and fill in

\item
            \tab a) Assume the Minimal Spanning Tree is not unique, but a T1 and T2 exist and are ezual \\
            \tab b) There exists an edge e1 in T1, and not in T2 \\
            \tab c) There exists an edge e2 in T2, and not in T1 \\
            \tab d) If T1 is an MST, then e2 + T1 must contain a cycle \\
            \tab e) Assume e1 \textgreater  e2 \\
            \tab f) In this case [(e2 + T2) - e1 \textless  T2] should be true but isn't \\
            \tab g) Thus, by contradiction we find that we can have one and only one unique minimal spanning tree \\

\item \\
    \tab Within HamP(G, u, v)\\
    \tab a) connect u and v with an edge, this produces a new graph H\\
    \tab b) run HamC(H) where H is the new graph with a path from u -\textgreater v\\
    \tab c) if HamC(H) returns true, then you should return true for HamP(G, u, v)\\
\end{enumerate}

\end{document}

